#include <stdio.h>
#define N 100 // データ数

//2〜99の素数を求めて配列に格納し、その中から指定した値が素数かどうかを探索する

/*
全体の目的
1.prime() 関数で 2〜99の素数を求めて配列に格納
2.入力された数（target）が 素数配列に含まれているかを探索
3.線形探索と二分探索の両方を使って確認
4.探索のたびに、**比較回数（COUNT）**も表示
*/

/*背景知識
素数：1と自分自身以外に約数がない正の整数（例：2, 3, 5, 7, 11…）
エラトステネスのふるい：
ある数 n が素数だったら、それ以外の n の倍数は絶対に素数じゃないので、除外していく方法

・例：
数字のリスト=[2, 3, 4, 5, 6, 7, 8, 9, 10]

ステップ1：2 は素数なので残す
2が素数なら2の倍数は素数でないため除外
→2 の倍数（4, 6, 8, 10）を除外
残り: [2, 3, -, 5, -, 7, -, 9, -]

ステップ2：3 は素数なので残す
 3 の倍数（6, 9）はすでに or 新たに除外　
 残り: [2, 3, -, 5, -, 7, -, -, -]
 
結果：残ったのが素数！
[2, 3, 5, 7]
*/
int prime(int x[]);
int LinearSearch(int x[],int n,int y);
int BinarySearch(int x[],int n,int y);

int COUNT;//カウント用のグローバル変数
 
int main(void)
{
    //最初に書かれているが、あとで prime(data) によって上書きされる
    int data[N]={11,22,33,44,55,66,77,88};
    int target,rc;
    int n;
 	
    //探したい数字をキーボドから入力
    n=prime(data);
    printf("目標データを入力：");
    scanf("%d",&target);
 
    printf("\n線形探索\n");
    //線形探索を実行して、結果（要素番号 or -1）を受け取る
    rc = LinearSearch(data,n,target);
    if(rc==-1) printf("素数ではありません\n");
    else printf("要素番号 %d の素数です\n",rc);
    printf("%d個の素数について調べました\n",COUNT);
 	
    COUNT=0;
    printf("\n二分探索\n");
    //二分探索を実行して、同様に結果を受け取る
    rc = BinarySearch(data,n,target);
    if(rc==-1) printf("素数ではありません\n");
    else printf("要素番号 %d の素数です\n",rc);
 	printf("%d個の素数について調べました\n",COUNT);
    
    return 0;
}

/*2以上N未満（今回は100未満）の素数を求めて、配列x[]に順番に入れる
エラトステネスのふるいという効率的な素数の判定法
*/
int prime(int x[])
{
    int i,n=0,m=0;
    
    //0〜99 までの「素数かどうか」を記録する配列
    //p[i] = 0 → 素数の候補
    //p[i] = 1 → 素数ではないと判定された数
    int p[N];  // チェック表の宣言
    
    //2～99までは、最初はすべて「素数の候補」として 0 にする
    for(i=2;i<N;i++) p[i]=0; 
    //0と1は素数でないので、1（除外）に設定
    p[0]=p[1]=1;  // 0と1は素数でないため素数候補から除外
    
    //n を 2, 3, 4, ..., N-1 まで順に試す
    //これは「ふるいの対象になる数」
    for(n=2;n<N;n++){
        //i = n * 2：n の2倍（最初の倍数）から始める
        //i += n：n の 3倍、4倍...と順番に増やす。
        //つまり、nの倍数（n×2, n×3, n×4...）を1つずつチェックして、素数から除外していく
        for(i=n*2;i<N;i+=n) p[i]=1; // nの倍数を素数候補から除外
    }
    
    //2からN未満（例えばN=100なら2〜99）まで順番に見ていく
    for(i=2;i<N;i++){
        //p[i] が 0 → 素数である
        //そのときだけ以下の処理を実行
        if(p[i]==0){
            //引数の配列Xのインデックス(m)にiの値を代入後、変数mを+1にする。
            x[m++]=i; 
            printf("%d ",i);
        }
    }
    printf("\n");
    return m;  //  素数として格納した個数を返し終了
}
//配列 x[] に y があるか、左から1つずつ順番に調べる
int LinearSearch(int x[],int n,int y)
{
    int i=0;
    while(i<n){
        COUNT++;
        if(x[i]==y) return i;// 見つかったらその位置を返す
        else i++;
    }
    return -1;// 見つからなかった場合
}

//整列済み配列に対して、高速に目的の値を探す方法
int BinarySearch(int x[],int n,int y)
{
    int min,mid,max;
    
    //真ん中の値と比較し、範囲を絞っていく
    min=0;
    max=n-1;
    while(min<=max){
        mid=(min+max)/2;
        COUNT++;
        if(x[mid]<y) min=mid+1;// 右側へ
        else if(x[mid]>y) max=mid-1;// 左側へ
        else return mid; // 見つかった
    }
    return -1;// 最後まで見つからなかった
}

