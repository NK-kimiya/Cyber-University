#include <stdio.h>
//配列の要素数を定義N=8
#define N 8  
/*コムソート：
コムソートでは、ある「間隔（gap）」で離れた要素同士を比較して入れ替え
最初は大きな間隔で比較し、少しずつその間隔を狭めていき、最後に隣同士（gap=1）
最初に gap=4 で 配列[0] と 配列[4] を比較して一気に遠くまで交換
その結果、大きな値を一気に後ろに移動させられるので、ソート効率が大幅に改善
*/
void BubbleSort(int x[],int n);
void CombSort(int x[],int n);

int main(void)
{
   int data[N]={3,2,8,5,7,1,6,4};
    int i;
    
    printf("\n並べ替え前\n");
    for(i=0;i<N;i++) printf("%d\t",data[i]);
    printf("\n");
    
    //BubbleSort(data,N);
    CombSort(data,N);
    printf("\n並べ替え後\n");
    for(i=0;i<N;i++) printf("%d\t",data[i]);
    printf("\n");

    return 0;
}

/*
x[]: ソート対象の 配列
n: 配列の 要素数
*/
void CombSort(int x[],int n)
{
    /*
    ・i: for文のループカウンタ
    ・tmp: 値を交換する時の一時的な入れ物
    ・gap: 比較の間隔（最初は配列サイズ、だんだん縮める）
    ・flg: 比較で入れ替えがあったかを示すフラグ（交換があったら1、なければ0）
    */
    int i,j,tmp,gap,flg=1;
    
    /*
    最初の間隔（gap）は配列の長さに設定
    例えば n = 8 なら、最初は8間隔 → 後で縮めていく
    */
    gap=n;
    /*
    gap > 1：まだ間隔が大きいなら続ける
    flg == 1：前回のループで入れ替えがあった場合も続ける
    */
    while(gap>1 || flg==1){
        /*
        gap を約1.3で割る（10/13 ≒ 0.769）ことで縮める
        これは CombSort 特有の 経験則に基づく縮小率
        n = 8 のとき、最初の gap は 8 × 0.769 ≒ 6.152 
		整数として扱うので gap = 6 
        */
        gap=gap*10/13;
        
        /*
        gap が 1 より小さくなったら、1に固定
        最後は隣接比較（バブルソートと同じ）になるようにする
        */
        if(gap<1) gap=1;
        
        //今回のループで「まだ交換がないかもしれない」と仮定して、いったんフラグを0にしておく
        flg=0;
        
        /*
        i 番目と i + gap 番目を比較する
        例：gap = 3 のとき → x[0] と x[3]、x[1] と x[4] など
        */
        for(i=0;i+gap<n;i++){
            
            //昇順にしたいので、左側（小さいインデックス）の値が大きければ入れ替え
            if( x[i]>x[i+gap]){
                
                //値の入れ替え処理（三つ組みで安全に入れ替え）
                tmp=x[i];
                x[i]=x[i+gap];
                x[i+gap]=tmp;
                
                //入れ替えがあったので、次の while ループも続けるようにフラグを 1 に戻す
                flg=1;
            }
        }
    }
    return;
}