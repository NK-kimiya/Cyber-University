#include <stdio.h>
//配列の要素数を定義N=8
#define N 8  
/*バブルソート：
隣り合うデータを比較して、順番が逆なら入れ替えるという操作を何度も繰り返すことで、データを並び替えるアルゴリズム
*/
void BubbleSort(int x[],int n);

int main(void)
{
    //並べ替える対象の**配列（8個の整数）**
   int data[N]={3,2,8,5,7,1,6,4};
    int i;
    
    //並び替える前の配列の状態を表示
    printf("\n並べ替え前\n");
    for(i=0;i<N;i++) printf("%d\t",data[i]);
    printf("\n");
    
    //配列 data を BubbleSort 関数に渡して、並び替えを実行
    BubbleSort(data,N);

    printf("\n並べ替え後\n");
    for(i=0;i<N;i++) printf("%d\t",data[i]);
    printf("\n");

    return 0;
}

//x[]: 並べ替え対象の配列
//n: 配列の要素数（データの個数）を受け取り
void BubbleSort(int x[],int n)
{
    /*
    ・i,j：ループのカウンタです。
    	・i: 内側のループ（隣同士の比較）
        ・j: 外側のループ（比較範囲を縮める）
    ・tmp: 一時的な値の入れ物配列の値を交換するときに使用
    ・flg（フラグ）:
    	・ートを続けるべきかを判断するためのスイッチ
        ・初期値は1（=「交換があるかもしれない」）でループを開始
    */
    int i,j,tmp,flg=1;
    
    /*
    ・j は、内側のループの比較の終点の位置
    ・flg==1の間、ループを続ける
    	・前のループで交換が一度も起きなければ終了
    ・要素は 0 番目から 7 番目まで → インデックスは 0〜7
    ・隣り合う要素の比較は、x[i] と x[i+1] を比較するため、
　	　最後に比較できる i の値は n - 2 = 6
     
    ・1回目の外側ループ（j = 7 のとき）
    	・内側は i = 0 から 6 までループし、x[6] と x[7] まで比較する
        ・一番大きい値が、x[7] に「バブル」のように浮かび上がる
    
    ・2回目の外側ループ（j = 6）
    	・今度は i = 0 から 5 まで比較（x[5] と x[6] まで）
        ・2番目に大きい値が、x[6] に来る
    
    こうして、比較範囲（内側ループ）が1つずつ短くなっていくので、
	外側ループのスタートは 一番広い比較範囲 = n - 1 になる。
    */
    for(j=n-1;flg==1;j--){
        //今回のループで交換が起きなければ、もう終了するつもりで flg をリセット
        flg=0;
        /*
        ・配列の先頭から、j 番目までの隣り合う要素を比較
        ・i と i + 1 を比べて、順番が逆なら入れ替え
        */
        for(i=0;i<j;i++){
            //x[i] が x[i + 1] より大きい場合、昇順にしたいので順番を入れ替える必要があると判断
            if(x[i]>x[i+1]){
                /*
                値の交換処理(一時的にtmpを使って3つの値の入れ替え)
                (例)
                x[i] = 5, x[i+1] = 3 の場合
                1.tmp = 5
                2.x[i] = 3
                3.x[i+1] = 5
                結果：5と3の位置が入れ替わる
                */
                tmp=x[i];
                x[i] =x[i+1];
                x[i+1]=tmp;
                flg=1;
            }
        }
    }
    return;
}